import { useEffect, useState, useRef } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import Avatar, { genConfig } from 'react-nice-avatar';
import { useAuthStore } from '../stores/authStore';
import { socketService } from '../services/socket';
import api from '../services/api';
import type { AvatarConfig } from '../types/avatar';
import { ALL_ROOMS } from '../config/rooms';
import { drawAllFurniture, checkCollision } from '../utils/furnitureRenderer';
import { useWebRTC } from '../hooks/useWebRTC';
import AvatarCustomizer from '../components/AvatarCustomizer';
import PhaserGame from '../components/PhaserGame';

interface Player {
    id: string;
    userId: string;
    userName: string;
    x: number;
    y: number;
    direction: string;
    isWalking: boolean;
    avatarConfig?: AvatarConfig;
    isVideoOn?: boolean;
    isAudioOn?: boolean;
    isDancing?: boolean;
}

interface ChatMessage {
    id: string;
    userId: string;
    userName: string;
    message: string;
    timestamp: Date;
}

const CANVAS_WIDTH = 1220;
const CANVAS_HEIGHT = 1200;
const MOVE_SPEED = 5;
const PROXIMITY_RADIUS = 150; // pixels

export default function SpaceRoom() {
    const { spaceId } = useParams();
    const navigate = useNavigate();
    const { user } = useAuthStore();
    const canvasRef = useRef<HTMLCanvasElement>(null);
    const videoRef = useRef<HTMLVideoElement>(null);
    const animationFrameRef = useRef<number>();
    const defaultAvatars = useRef<Map<string, AvatarConfig>>(new Map());
    const [localStream, setLocalStream] = useState<MediaStream | null>(null);
    const previousNearbyUsers = useRef<Set<string>>(new Set());

    const [space, setSpace] = useState<any>(null);
    const [players, setPlayers] = useState<Map<string, Player>>(new Map());
    const [myPosition, setMyPosition] = useState({ x: 340, y: 500, direction: 'down', isWalking: false });
    const [isVideoOn, setIsVideoOn] = useState(false);
    const [isAudioOn, setIsAudioOn] = useState(false);
    const [isDancing, setIsDancing] = useState(false);
    const [showAvatarCustomizer, setShowAvatarCustomizer] = useState(false);
    const [myAvatarConfig, setMyAvatarConfig] = useState<AvatarConfig>(genConfig({ isGradient: true }));
    const [chatMessages, setChatMessages] = useState<ChatMessage[]>([]);
    const [newMessage, setNewMessage] = useState('');
    const [joinNotification, setJoinNotification] = useState<string | null>(null);
    const [waveNotification, setWaveNotification] = useState<string | null>(null);
    const [showChat, setShowChat] = useState(true);
    const [isScreenSharing, setIsScreenSharing] = useState(false);
    const [socketReady, setSocketReady] = useState(false);
    const [fullscreenVideo, setFullscreenVideo] = useState<string | null>(null); // userId of fullscreen video
    const [chatTab, setChatTab] = useState<'all' | 'private'>('all');
    const [selectedPrivateUser, setSelectedPrivateUser] = useState<string | null>(null);
    const [privateChats, setPrivateChats] = useState<Map<string, Array<{ id: string; userName: string; message: string; isMine: boolean; timestamp: Date }>>>(new Map());
    const [notification, setNotification] = useState<{ userName: string; message: string } | null>(null);

    const { createOffer, closePeerConnection, remoteStreams } = useWebRTC(
        localStream,
        spaceId,
        socketReady
    );

    // Initialize
    useEffect(() => {
        if (!user || !spaceId) return;

        const initSpace = async () => {
            try {
                const response = await api.get(`/spaces/${spaceId}`);
                setSpace(response.data);

                // Connect to socket
                socketService.connect();

                socketService.on('connect', () => {
                    console.log('üîå Socket connected in SpaceRoom');
                    setSocketReady(true);
                    socketService.joinSpace(spaceId, user.id, user.displayName, myPosition.x, myPosition.y);
                });

                // Listen for other players
                socketService.on('players:list', (existingPlayers: Player[]) => {
                    setPlayers(new Map(existingPlayers.map(p => [p.id, p])));
                });

                socketService.on('player:joined', (player: Player) => {
                    setPlayers(prev => new Map(prev).set(player.id, player));
                    setJoinNotification(`‚ú® ${player.userName} joined!`);
                    setTimeout(() => setJoinNotification(null), 3000);
                });

                socketService.on('player:left', (data: { playerId: string }) => {
                    setPlayers(prev => {
                        const newMap = new Map(prev);
                        newMap.delete(data.playerId);
                        return newMap;
                    });
                });

                socketService.on('player:moved', (data: any) => {
                    setPlayers(prev => {
                        const newMap = new Map(prev);
                        const player = newMap.get(data.playerId);
                        if (player) {
                            player.x = data.x;
                            player.y = data.y;
                            player.direction = data.direction;
                            player.isWalking = data.isWalking;
                        }
                        return newMap;
                    });
                });

                socketService.on('player:video-changed', (data: { playerId: string; isVideoOn: boolean }) => {
                    setPlayers(prev => {
                        const newMap = new Map(prev);
                        const player = newMap.get(data.playerId);
                        if (player) {
                            player.isVideoOn = data.isVideoOn;
                        }
                        return newMap;
                    });
                });

                socketService.on('player:audio-changed', (data: { playerId: string; isAudioOn: boolean }) => {
                    setPlayers(prev => {
                        const newMap = new Map(prev);
                        const player = newMap.get(data.playerId);
                        if (player) {
                            player.isAudioOn = data.isAudioOn;
                        }
                        return newMap;
                    });
                });

                socketService.on('player:dance-changed', (data: { playerId: string; isDancing: boolean }) => {
                    setPlayers(prev => {
                        const newMap = new Map(prev);
                        const player = newMap.get(data.playerId);
                        if (player) {
                            player.isDancing = data.isDancing;
                        }
                        return newMap;
                    });
                });

                socketService.on('player:avatar-changed', (data: { playerId: string; config: AvatarConfig }) => {
                    setPlayers(prev => {
                        const newMap = new Map(prev);
                        const player = newMap.get(data.playerId);
                        if (player) {
                            player.avatarConfig = data.config;
                        }
                        return newMap;
                    });
                });

                socketService.on('player:waved', (data: { fromUserName: string }) => {
                    setWaveNotification(`üëã ${data.fromUserName} waved at you!`);
                    setTimeout(() => setWaveNotification(null), 3000);
                });

            } catch (error) {
                console.error('Failed to join space:', error);
            }
        };

        initSpace();

        return () => {
            socketService.disconnect();
        };
    }, [spaceId, user]);

    // Movement Loop
    useEffect(() => {
        const handleKeyDown = (e: KeyboardEvent) => {
            if (document.activeElement?.tagName === 'INPUT') return;

            let dx = 0;
            let dy = 0;
            let direction = myPosition.direction;

            switch (e.key) {
                case 'ArrowUp': case 'w': dy = -MOVE_SPEED; direction = 'up'; break;
                case 'ArrowDown': case 's': dy = MOVE_SPEED; direction = 'down'; break;
                case 'ArrowLeft': case 'a': dx = -MOVE_SPEED; direction = 'left'; break;
                case 'ArrowRight': case 'd': dx = MOVE_SPEED; direction = 'right'; break;
                default: return;
            }

            const newX = Math.max(0, Math.min(CANVAS_WIDTH - 40, myPosition.x + dx));
            const newY = Math.max(0, Math.min(CANVAS_HEIGHT - 40, myPosition.y + dy));

            const allFurniture = ALL_ROOMS.flatMap(room => room.furniture);

            if (!checkCollision(newX, newY, allFurniture)) {
                setMyPosition(prev => ({ ...prev, x: newX, y: newY, direction, isWalking: true }));
                socketService.emitMove(newX, newY, direction, true);
            }
        };

        const handleKeyUp = () => {
            setMyPosition(prev => ({ ...prev, isWalking: false }));
            socketService.emitMove(myPosition.x, myPosition.y, myPosition.direction, false);
        };

        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);

        return () => {
            window.removeEventListener('keydown', handleKeyDown);
            window.removeEventListener('keyup', handleKeyUp);
        };
    }, [myPosition, spaceId]);

    // Render Loop (Canvas for background only)
    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        const render = () => {
            // Background
            ctx.fillStyle = '#e8f4f8';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Grid floor
            ctx.strokeStyle = 'rgba(0,0,0,0.05)';
            ctx.lineWidth = 1;
            for (let x = 0; x < CANVAS_WIDTH; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, CANVAS_HEIGHT);
                ctx.stroke();
            }
            for (let y = 0; y < CANVAS_HEIGHT; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(CANVAS_WIDTH, y);
                ctx.stroke();
            }

            // Draw rooms and furniture
            ALL_ROOMS.forEach(room => {
                const { bounds, name } = room;
                ctx.fillStyle = 'rgba(102, 126, 234, 0.05)';
                ctx.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 3;
                ctx.strokeRect(bounds.x, bounds.y, bounds.width, bounds.height);

                ctx.font = 'bold 20px Arial';
                ctx.fillStyle = '#667eea';
                ctx.fillText(name, bounds.x + 10, bounds.y + 30);

                drawAllFurniture(ctx, room.furniture);
            });

            animationFrameRef.current = requestAnimationFrame(render);
        };

        render();
        return () => cancelAnimationFrame(animationFrameRef.current!);
    }, []);

    // Video/Screen/Audio handling
    useEffect(() => {
        const updateMediaStream = async () => {
            // Stop existing streams first
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                setLocalStream(null);
            }

            if (isVideoOn && !isScreenSharing) {
                // Camera mode with audio
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: true,
                        audio: isAudioOn
                    });
                    setLocalStream(stream);
                    if (videoRef.current) {
                        videoRef.current.srcObject = stream;
                    }
                    console.log('üìπ Camera stream started with audio:', isAudioOn);
                } catch (err) {
                    console.error('Error accessing camera:', err);
                }
            } else if (isScreenSharing) {
                // Screen share mode
                try {
                    const screenStream = await navigator.mediaDevices.getDisplayMedia({
                        video: true,
                        audio: true
                    });

                    // If audio is enabled, also get microphone audio
                    if (isAudioOn) {
                        try {
                            const audioStream = await navigator.mediaDevices.getUserMedia({
                                audio: true,
                                video: false
                            });
                            // Combine screen video with microphone audio
                            const combinedStream = new MediaStream([
                                ...screenStream.getVideoTracks(),
                                ...audioStream.getAudioTracks()
                            ]);
                            setLocalStream(combinedStream);
                            if (videoRef.current) {
                                videoRef.current.srcObject = combinedStream;
                            }
                        } catch (audioErr) {
                            console.warn('Could not get microphone for screen share:', audioErr);
                            setLocalStream(screenStream);
                            if (videoRef.current) {
                                videoRef.current.srcObject = screenStream;
                            }
                        }
                    } else {
                        setLocalStream(screenStream);
                        if (videoRef.current) {
                            videoRef.current.srcObject = screenStream;
                        }
                    }

                    // Listen for screen share stop
                    screenStream.getVideoTracks()[0].onended = () => {
                        console.log('Screen share stopped by user');
                        setIsScreenSharing(false);
                        setIsVideoOn(false);
                    };
                    console.log('üñ•Ô∏è Screen share started with audio:', isAudioOn);
                } catch (err) {
                    console.error('Error accessing screen:', err);
                    setIsScreenSharing(false);
                }
            } else if (!isVideoOn && !isScreenSharing) {
                // No video - but might still have audio only
                if (isAudioOn) {
                    try {
                        const audioStream = await navigator.mediaDevices.getUserMedia({
                            audio: true,
                            video: false
                        });
                        setLocalStream(audioStream);
                        console.log('üé§ Audio-only stream started');
                    } catch (err) {
                        console.error('Error accessing microphone:', err);
                    }
                } else {
                    // Stop all streams
                    if (videoRef.current) {
                        videoRef.current.srcObject = null;
                    }
                }
            }
        };

        updateMediaStream();
    }, [isVideoOn, isAudioOn, isScreenSharing]);

    const toggleVideo = () => {
        const newState = !isVideoOn;
        setIsVideoOn(newState);
        if (isScreenSharing) setIsScreenSharing(false); // Stop screen share if switching to camera
        socketService.emitVideoToggle(newState);
    };

    const toggleAudio = () => {
        const newState = !isAudioOn;
        setIsAudioOn(newState);

        // Update audio track in current stream
        if (localStream) {
            localStream.getAudioTracks().forEach(track => {
                track.enabled = newState;
            });
        }

        socketService.emitAudioToggle(newState);
        console.log('üé§ Audio toggled:', newState);
    };

    const toggleScreenShare = () => {
        if (isScreenSharing) {
            // Stop screen sharing
            setIsScreenSharing(false);
            setIsVideoOn(false);
            socketService.emitVideoToggle(false);
            console.log('üñ•Ô∏è Stopped screen sharing');
        } else {
            // Start screen sharing
            setIsScreenSharing(true);
            setIsVideoOn(true); // Enable video to trigger stream
            socketService.emitVideoToggle(true);
            console.log('üñ•Ô∏è Started screen sharing');
        }
    };

    const handleAvatarSave = (config: AvatarConfig) => {
        setMyAvatarConfig(config);
        const socket = socketService.getSocket();
        if (socket) {
            socket.emit('player:avatar-update', { spaceId, config });
        }
        setShowAvatarCustomizer(false);
    };

    // Format message timestamp
    const formatMessageTime = (timestamp: Date) => {
        const now = new Date();
        const msgDate = new Date(timestamp);
        const isToday = now.toDateString() === msgDate.toDateString();

        if (isToday) {
            // Just show time if today
            return msgDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
        } else {
            // Show date and time if different day
            return msgDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) + ' ' +
                msgDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
        }
    };

    const sendMessage = (e: React.FormEvent) => {
        e.preventDefault();
        if (!newMessage.trim() || !user || !spaceId) return;

        const socket = socketService.getSocket();
        console.log('üí¨ Socket state:', socket?.connected, 'User:', user?.id, 'Space:', spaceId);

        if (socket && socket.connected) {
            if (chatTab === 'private' && selectedPrivateUser) {
                // Send private message
                socket.emit('chat:private', {
                    spaceId,
                    targetUserId: selectedPrivateUser,
                    message: newMessage.trim()
                });

                // Add to own private chat history
                setPrivateChats(prev => {
                    const newChats = new Map(prev);
                    const messages = newChats.get(selectedPrivateUser) || [];
                    messages.push({
                        id: `${Date.now()}-${user.id}-${Math.random()}`,
                        userName: user.displayName,
                        message: newMessage.trim(),
                        isMine: true,
                        timestamp: new Date()
                    });
                    newChats.set(selectedPrivateUser, messages);
                    return newChats;
                });

                console.log('üí¨ Sending private message to:', selectedPrivateUser);
            } else {
                // Send public message
                console.log('üí¨ Emitting public message:', newMessage.trim());
                socket.emit('chat:message', {
                    spaceId,
                    message: newMessage.trim()
                });
                console.log('üí¨ Public message emitted');
            }
        } else {
            console.error('‚ùå Socket not connected!');
        }
        setNewMessage('');
    };

    // Play notification sound
    const playNotificationSound = () => {
        const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIGGS56+adTBAKUKfj8LZiGwU7k9r0yXUqBSJzxe/glEILE2Cx5+qoVBIJSKDg87hgGQU=');
        audio.volume = 0.3;
        audio.play().catch(err => console.log('Sound play failed:', err));
    };

    // Listen for chat messages (public)
    useEffect(() => {
        const socket = socketService.getSocket();
        console.log('üîå Setting up chat listeners, socket exists:', !!socket);
        if (!socket) return;

        const handleChatMessage = (data: { userId: string; userName: string; message: string; timestamp: string }) => {
            console.log('üí¨ Received chat message:', data);
            console.log('üí¨ Current user:', user?.id);
            console.log('üí¨ Current chatMessages length:', chatMessages.length);

            // Show notification if not from self
            if (data.userId !== user?.id) {
                console.log('üí¨ Showing notification for message from:', data.userName);
                setNotification({ userName: data.userName, message: data.message });
                playNotificationSound();

                // Auto-hide notification after 5 seconds
                setTimeout(() => setNotification(null), 5000);
            }

            const newMsg = {
                id: `${Date.now()}-${data.userId}-${Math.random()}`,
                userId: data.userId,
                userName: data.userName,
                message: data.message,
                timestamp: new Date(data.timestamp)
            };
            console.log('üí¨ Adding message to state:', newMsg);

            setChatMessages(prev => {
                console.log('üí¨ Previous messages:', prev.length);
                const updated = [...prev, newMsg];
                console.log('üí¨ Updated messages:', updated.length);
                return updated;
            });
        };

        const handlePrivateMessage = (data: { fromUserId: string; fromUserName: string; message: string; timestamp: string }) => {
            console.log('üí¨ Received private message:', data);

            // Show notification
            setNotification({ userName: data.fromUserName, message: data.message });
            playNotificationSound();
            setTimeout(() => setNotification(null), 5000);

            // Add to private chat history
            setPrivateChats(prev => {
                const newChats = new Map(prev);
                const messages = newChats.get(data.fromUserId) || [];
                messages.push({
                    id: `${Date.now()}-${data.fromUserId}-${Math.random()}`,
                    userName: data.fromUserName,
                    message: data.message,
                    isMine: false,
                    timestamp: new Date(data.timestamp)
                });
                newChats.set(data.fromUserId, messages);
                return newChats;
            });
        };

        console.log('üí¨ Registering chat listeners...');
        socket.on('chat:message', handleChatMessage);
        socket.on('chat:private', handlePrivateMessage);
        console.log('üí¨ Chat listeners registered');

        return () => {
            console.log('üí¨ Cleaning up chat listeners');
            socket.off('chat:message', handleChatMessage);
            socket.off('chat:private', handlePrivateMessage);
        };
    }, [user, socketReady]);

    // Helper to get or create default avatar for a player
    const getPlayerAvatar = (player: Player): AvatarConfig => {
        if (player.avatarConfig) return player.avatarConfig;

        if (!defaultAvatars.current.has(player.id)) {
            defaultAvatars.current.set(player.id, genConfig({ isGradient: true }));
        }
        return defaultAvatars.current.get(player.id)!;
    };

    // Calculate nearby players for proximity chat
    const nearbyPlayers = Array.from(players.values()).filter(player => {
        const dx = player.x - myPosition.x;
        const dy = player.y - myPosition.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance <= PROXIMITY_RADIUS;
    });

    // Manage WebRTC connections based on proximity
    useEffect(() => {
        if (!localStream) return;

        const currentNearbyUserIds = new Set(nearbyPlayers.map(p => p.userId));
        const previousUserIds = previousNearbyUsers.current;

        // Users who just came into range
        const newUsers = [...currentNearbyUserIds].filter(id => !previousUserIds.has(id));

        // Users who just left range
        const leftUsers = [...previousUserIds].filter(id => !currentNearbyUserIds.has(id));

        // Create WebRTC connections for new nearby users (only if we have audio OR video enabled)
        if (isVideoOn || isAudioOn) {
            newUsers.forEach(userId => {
                console.log('Creating offer for nearby user:', userId, '(video:', isVideoOn, 'audio:', isAudioOn, ')');
                createOffer(userId);
            });
        }

        // Close connections for users who left
        leftUsers.forEach(userId => {
            console.log('Closing connection for user who moved away:', userId);
            closePeerConnection(userId);
        });

        previousNearbyUsers.current = currentNearbyUserIds;
    }, [nearbyPlayers, localStream, createOffer, closePeerConnection, isVideoOn, isAudioOn]);

    return (
        <div style={{ display: 'flex', height: '100vh', width: '100vw', overflow: 'hidden' }}>
            {/* Main Game Area */}
            <div style={{ flex: 1, position: 'relative', overflow: 'hidden', background: '#2d3748' }}>

                {/* Header */}
                <div style={{
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    right: 0,
                    padding: '16px 24px',
                    background: 'linear-gradient(to bottom, rgba(0,0,0,0.8), transparent)',
                    color: 'white',
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    zIndex: 100
                }}>
                    <div>
                        <h1 style={{ margin: 0, fontSize: '24px', fontWeight: 'bold' }}>{space?.name || 'Loading...'}</h1>
                        <div style={{ fontSize: '14px', opacity: 0.8 }}>
                            üë§ {players.size + 1} online ‚Ä¢ üó∫Ô∏è All 3 rooms visible ‚Ä¢ WASD to move
                        </div>
                    </div>
                    <button
                        onClick={() => navigate('/dashboard')}
                        style={{
                            padding: '8px 16px',
                            background: 'rgba(255,255,255,0.1)',
                            border: '1px solid rgba(255,255,255,0.2)',
                            borderRadius: '8px',
                            color: 'white',
                            cursor: 'pointer',
                            backdropFilter: 'blur(4px)'
                        }}
                    >
                        ‚¨Ö Exit
                    </button>
                </div>

                {/* Phaser Game Canvas */}
                <div style={{
                    position: 'relative',
                    width: '1220px',
                    height: '680px',
                    margin: '0 auto'
                }}>
                    <PhaserGame
                        socket={socketService.getSocket()}
                        userId={user?.id}
                        userName={user?.displayName}
                        spaceId={spaceId}
                    />
                </div>

                {/* UI Overlays */}
                {joinNotification && (
                    <div style={{ position: 'absolute', top: '80px', left: '50%', transform: 'translateX(-50%)', background: '#667eea', color: 'white', padding: '12px 24px', borderRadius: '8px', fontWeight: 'bold', zIndex: 1000 }}>
                        {joinNotification}
                    </div>
                )}

                {/* Controls */}
                <div style={{ position: 'fixed', bottom: '30px', left: '50%', transform: 'translateX(-50%)', display: 'flex', gap: '12px', zIndex: 1000 }}>
                    <button onClick={toggleVideo} style={{ padding: '12px 24px', borderRadius: '8px', border: 'none', background: (isVideoOn && !isScreenSharing) ? '#48bb78' : '#e53e3e', color: 'white', fontWeight: 'bold', cursor: 'pointer', boxShadow: '0 2px 8px rgba(0,0,0,0.2)' }}>
                        {(isVideoOn && !isScreenSharing) ? 'üìπ Video On' : 'üìπ Video Off'}
                    </button>
                    <button onClick={toggleAudio} style={{ padding: '12px 24px', borderRadius: '8px', border: 'none', background: isAudioOn ? '#48bb78' : '#e53e3e', color: 'white', fontWeight: 'bold', cursor: 'pointer', boxShadow: '0 2px 8px rgba(0,0,0,0.2)' }}>
                        {isAudioOn ? 'üé§ Mic On' : 'üé§ Mic Off'}
                    </button>
                    <button onClick={toggleScreenShare} style={{ padding: '12px 24px', borderRadius: '8px', border: 'none', background: isScreenSharing ? '#48bb78' : '#667eea', color: 'white', fontWeight: 'bold', cursor: 'pointer', boxShadow: '0 2px 8px rgba(0,0,0,0.2)' }}>
                        {isScreenSharing ? 'üñ•Ô∏è Sharing...' : 'üñ•Ô∏è Share Screen'}
                    </button>
                    <button onClick={() => setShowAvatarCustomizer(true)} style={{ padding: '12px 24px', borderRadius: '8px', border: 'none', background: '#667eea', color: 'white', fontWeight: 'bold', cursor: 'pointer', boxShadow: '0 2px 8px rgba(0,0,0,0.2)' }}>
                        üëï Customize Avatar
                    </button>
                </div>

                {/* Proximity Info */}
                {nearbyPlayers.length > 0 && (
                    <div style={{ position: 'fixed', top: '100px', left: '20px', background: 'rgba(0,0,0,0.8)', color: 'white', padding: '12px 16px', borderRadius: '8px', zIndex: 1000, maxWidth: '200px' }}>
                        <div style={{ fontWeight: 'bold', marginBottom: '8px', color: '#667eea' }}>üîä Nearby ({nearbyPlayers.length})</div>
                        {nearbyPlayers.map(p => (
                            <div key={p.id} style={{ fontSize: '12px', padding: '4px 0', borderBottom: '1px solid rgba(255,255,255,0.1)' }}>
                                {p.userName}
                            </div>
                        ))}
                    </div>
                )}
            </div>

            {/* Avatar Customizer Modal */}
            {showAvatarCustomizer && (
                <AvatarCustomizer
                    initialConfig={myAvatarConfig}
                    onSave={handleAvatarSave}
                    onClose={() => setShowAvatarCustomizer(false)}
                />
            )}
        </div>

        {/* Chat Sidebar */ }
    {
        showChat && (
            <div style={{ width: '300px', background: '#1a202c', borderLeft: '1px solid #2d3748', display: 'flex', flexDirection: 'column' }}>
                {/* Chat Header with Close */}
                <div style={{ padding: '20px', borderBottom: '1px solid #2d3748', color: 'white', fontWeight: 'bold', display: 'flex', justifyContent: 'space-between' }}>
                    <span>üí¨ Chat</span>
                    <button onClick={() => setShowChat(false)} style={{ background: 'none', border: 'none', color: '#718096', cursor: 'pointer', fontSize: '18px' }}>‚úï</button>
                </div>

                {/* Tabs */}
                <div style={{ display: 'flex', borderBottom: '1px solid #2d3748' }}>
                    <button
                        onClick={() => setChatTab('all')}
                        style={{
                            flex: 1,
                            padding: '12px',
                            background: chatTab === 'all' ? '#667eea' : 'transparent',
                            color: 'white',
                            border: 'none',
                            cursor: 'pointer',
                            fontWeight: chatTab === 'all' ? 'bold' : 'normal',
                            transition: 'all 0.2s'
                        }}
                    >
                        All
                    </button>
                    <button
                        onClick={() => setChatTab('private')}
                        style={{
                            flex: 1,
                            padding: '12px',
                            background: chatTab === 'private' ? '#667eea' : 'transparent',
                            color: 'white',
                            border: 'none',
                            cursor: 'pointer',
                            fontWeight: chatTab === 'private' ? 'bold' : 'normal',
                            transition: 'all 0.2s'
                        }}
                    >
                        Private
                    </button>
                </div>

                {/* Chat Content */}
                {chatTab === 'all' ? (
                    <>
                        {/* Public Messages */}
                        <div style={{ flex: 1, padding: '20px', overflowY: 'auto', display: 'flex', flexDirection: 'column', gap: '12px' }}>
                            {chatMessages.length === 0 && <div style={{ color: '#718096', textAlign: 'center' }}>No messages yet...</div>}
                            {chatMessages.map(msg => (
                                <div key={msg.id} style={{ marginBottom: '8px' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '4px' }}>
                                        <div style={{ color: '#667eea', fontSize: '12px', fontWeight: 'bold' }}>
                                            {msg.userName}
                                        </div>
                                        <div style={{ color: '#718096', fontSize: '10px' }}>
                                            {formatMessageTime(msg.timestamp)}
                                        </div>
                                    </div>
                                    <div style={{ color: 'white', fontSize: '14px', wordWrap: 'break-word', background: '#2d3748', padding: '8px', borderRadius: '8px' }}>
                                        {msg.message}
                                    </div>
                                </div>
                            ))}
                        </div>

                        {/* Message Input for All */}
                        <div style={{ padding: '20px', borderTop: '1px solid #2d3748' }}>
                            <form onSubmit={sendMessage} style={{ display: 'flex', gap: '8px' }}>
                                <input
                                    type="text"
                                    value={newMessage}
                                    onChange={e => setNewMessage(e.target.value)}
                                    placeholder="Message everyone..."
                                    style={{ flex: 1, padding: '12px', borderRadius: '8px', border: 'none', background: '#2d3748', color: 'white' }}
                                />
                                <button type="submit" style={{ padding: '12px 16px', background: '#667eea', color: 'white', border: 'none', borderRadius: '8px', cursor: 'pointer', fontWeight: 'bold' }}>Send</button>
                            </form>
                        </div>
                    </>
                ) : (
                    <>
                        {/* Private Chat */}
                        {selectedPrivateUser ? (
                            <>
                                {/* Header with back button */}
                                <div style={{ padding: '12px 20px', background: '#2d3748', display: 'flex', alignItems: 'center', gap: '8px' }}>
                                    <button
                                        onClick={() => setSelectedPrivateUser(null)}
                                        style={{ background: 'none', border: 'none', color: 'white', cursor: 'pointer', fontSize: '16px' }}
                                    >
                                        ‚Üê Back
                                    </button>
                                    <span style={{ color: 'white', fontWeight: 'bold' }}>
                                        {Array.from(players.values()).find(p => p.userId === selectedPrivateUser)?.userName || 'User'}
                                    </span>
                                </div>

                                {/* Private Messages */}
                                <div style={{ flex: 1, padding: '20px', overflowY: 'auto', display: 'flex', flexDirection: 'column', gap: '12px' }}>
                                    {(!privateChats.has(selectedPrivateUser) || privateChats.get(selectedPrivateUser)!.length === 0) && (
                                        <div style={{ color: '#718096', textAlign: 'center' }}>Start a private conversation...</div>
                                    )}
                                    {privateChats.get(selectedPrivateUser)?.map(msg => (
                                        <div key={msg.id} style={{ display: 'flex', flexDirection: 'column', alignItems: msg.isMine ? 'flex-end' : 'flex-start' }}>
                                            <div style={{
                                                color: 'white',
                                                fontSize: '14px',
                                                wordWrap: 'break-word',
                                                background: msg.isMine ? '#667eea' : '#2d3748',
                                                padding: '8px 12px',
                                                borderRadius: '12px',
                                                maxWidth: '80%',
                                                position: 'relative'
                                            }}>
                                                {msg.message}
                                            </div>
                                            <div style={{ color: '#718096', fontSize: '9px', marginTop: '2px' }}>
                                                {formatMessageTime(msg.timestamp)}
                                            </div>
                                        </div>
                                    ))}
                                </div>

                                {/* Message Input for Private */}
                                <div style={{ padding: '20px', borderTop: '1px solid #2d3748' }}>
                                    <form onSubmit={sendMessage} style={{ display: 'flex', gap: '8px' }}>
                                        <input
                                            type="text"
                                            value={newMessage}
                                            onChange={e => setNewMessage(e.target.value)}
                                            placeholder="Message privately..."
                                            style={{ flex: 1, padding: '12px', borderRadius: '8px', border: 'none', background: '#2d3748', color: 'white' }}
                                        />
                                        <button type="submit" style={{ padding: '12px 16px', background: '#667eea', color: 'white', border: 'none', borderRadius: '8px', cursor: 'pointer', fontWeight: 'bold' }}>Send</button>
                                    </form>
                                </div>
                            </>
                        ) : (
                            <>
                                {/* User List */}
                                <div style={{ flex: 1, padding: '20px', overflowY: 'auto' }}>
                                    <div style={{ color: '#718096', fontSize: '12px', marginBottom: '12px', fontWeight: 'bold' }}>
                                        Select a user to chat privately
                                    </div>
                                    {Array.from(players.values()).map(player => (
                                        <button
                                            key={player.userId}
                                            onClick={() => setSelectedPrivateUser(player.userId)}
                                            style={{
                                                width: '100%',
                                                padding: '12px',
                                                marginBottom: '8px',
                                                background: '#2d3748',
                                                border: 'none',
                                                borderRadius: '8px',
                                                color: 'white',
                                                cursor: 'pointer',
                                                textAlign: 'left',
                                                display: 'flex',
                                                alignItems: 'center',
                                                gap: '8px',
                                                transition: 'background 0.2s'
                                            }}
                                            onMouseEnter={(e) => e.currentTarget.style.background = '#4a5568'}
                                            onMouseLeave={(e) => e.currentTarget.style.background = '#2d3748'}
                                        >
                                            <div style={{ width: '8px', height: '8px', borderRadius: '50%', background: '#48bb78' }}></div>
                                            <span>{player.userName}</span>
                                        </button>
                                    ))}
                                </div>
                            </>
                        )}
                    </>
                )}
            </div>
        )
    }

    {
        !showChat && (
            <button
                onClick={() => setShowChat(true)}
                style={{
                    position: 'fixed',
                    bottom: '20px',
                    right: '20px',
                    background: '#667eea',
                    color: 'white',
                    border: 'none',
                    borderRadius: '50%',
                    width: '50px',
                    height: '50px',
                    fontSize: '24px',
                    cursor: 'pointer',
                    boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
                    zIndex: 1000
                }}
            >
                üí¨
            </button>
        )
    }

    {/* Fullscreen Video Overlay */ }
    {
        fullscreenVideo && (
            <div style={{
                position: 'fixed',
                top: 0,
                left: 0,
                right: '360px', // Leave space for sidebar (320px + some margin)
                bottom: '80px', // Leave space for bottom controls
                background: 'rgba(0,0,0,0.95)', // Dark opaque background
                zIndex: 1500,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                padding: '80px 20px 20px 20px'
            }}>
                {fullscreenVideo === 'me' ? (
                    // Own video fullscreen
                    <div style={{ position: 'relative', width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                        <video
                            autoPlay
                            muted
                            playsInline
                            ref={(videoElement) => {
                                if (videoElement && localStream) {
                                    videoElement.srcObject = localStream;
                                }
                            }}
                            style={{
                                width: '100%',
                                height: '100%',
                                objectFit: 'cover',
                                transform: 'scaleX(-1)',
                                borderRadius: '8px',
                                boxShadow: '0 8px 32px rgba(0,0,0,0.4)'
                            }}
                        />
                        <div style={{
                            position: 'absolute',
                            top: '-50px',
                            left: '0',
                            right: '0',
                            display: 'flex',
                            justifyContent: 'space-between',
                            alignItems: 'center'
                        }}>
                            <span style={{ color: 'white', fontSize: '18px', fontWeight: 'bold', textShadow: '0 2px 4px rgba(0,0,0,0.8)' }}>
                                You {isScreenSharing && '(Screen)'}
                            </span>
                            <button
                                onClick={() => setFullscreenVideo(null)}
                                style={{
                                    background: 'rgba(0,0,0,0.8)',
                                    border: '2px solid white',
                                    borderRadius: '8px',
                                    color: 'white',
                                    padding: '8px 16px',
                                    cursor: 'pointer',
                                    fontSize: '14px',
                                    fontWeight: 'bold'
                                }}
                            >
                                ‚úï Close
                            </button>
                        </div>
                    </div>
                ) : (
                    // Remote video fullscreen
                    (() => {
                        const player = nearbyPlayers.find(p => p.userId === fullscreenVideo);
                        const stream = player ? remoteStreams.get(player.userId) : null;
                        if (!player || !stream) return null;

                        return (
                            <div style={{ position: 'relative', width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                                <video
                                    autoPlay
                                    playsInline
                                    ref={(videoElement) => {
                                        if (videoElement && stream) {
                                            videoElement.srcObject = stream;
                                        }
                                    }}
                                    style={{
                                        width: '100%',
                                        height: '100%',
                                        objectFit: 'cover',
                                        borderRadius: '8px',
                                        boxShadow: '0 8px 32px rgba(0,0,0,0.4)'
                                    }}
                                />
                                <div style={{
                                    position: 'absolute',
                                    top: '-50px',
                                    left: '0',
                                    right: '0',
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center'
                                }}>
                                    <span style={{ color: 'white', fontSize: '18px', fontWeight: 'bold', textShadow: '0 2px 4px rgba(0,0,0,0.8)' }}>
                                        {player.userName}
                                    </span>
                                    <button
                                        onClick={() => setFullscreenVideo(null)}
                                        style={{
                                            background: 'rgba(0,0,0,0.8)',
                                            border: '2px solid white',
                                            borderRadius: '8px',
                                            color: 'white',
                                            padding: '8px 16px',
                                            cursor: 'pointer',
                                            fontSize: '14px',
                                            fontWeight: 'bold'
                                        }}
                                    >
                                        ‚úï Close
                                    </button>
                                </div>
                            </div>
                        );
                    })()
                )}
            </div>
        )
    }

    {/* Right Sidebar - All Videos */ }
    {
        (isVideoOn || nearbyPlayers.some(p => remoteStreams.has(p.userId) && p.isVideoOn)) && (
            <div style={{
                position: 'absolute',
                top: '80px',
                right: showChat ? '420px' : '20px',
                width: '320px',
                maxHeight: 'calc(100vh - 100px)',
                background: 'rgba(0,0,0,0.7)',
                padding: '16px',
                display: 'flex',
                flexDirection: 'column',
                gap: '12px',
                overflowY: 'auto',
                overflowX: 'hidden',
                zIndex: 100,
                backdropFilter: 'blur(10px)',
                borderRadius: '12px',
                transition: 'right 0.3s ease',
                scrollbarWidth: 'thin',
                scrollbarColor: '#48bb78 rgba(0,0,0,0.3)'
            } as React.CSSProperties}>
                {/* Own Video */}
                {isVideoOn && localStream && fullscreenVideo !== 'me' && (
                    <div
                        style={{
                            position: 'relative',
                            width: '100%',
                            aspectRatio: '16/9',
                            background: 'black',
                            borderRadius: '12px',
                            overflow: 'hidden',
                            border: '2px solid #667eea',
                            boxShadow: '0 4px 12px rgba(102, 126, 234, 0.3)',
                            cursor: 'pointer'
                        }}
                        onClick={() => setFullscreenVideo('me')}
                    >
                        <video
                            autoPlay
                            muted
                            playsInline
                            ref={(videoElement) => {
                                if (videoElement && localStream) {
                                    videoElement.srcObject = localStream;
                                }
                            }}
                            style={{
                                width: '100%',
                                height: '100%',
                                objectFit: 'contain',
                                transform: 'scaleX(-1)'
                            }}
                        />

                        <div style={{
                            position: 'absolute',
                            top: '8px',
                            left: '8px',
                            right: '8px',
                            display: 'flex',
                            justifyContent: 'space-between',
                            alignItems: 'center',
                            background: 'rgba(0,0,0,0.6)',
                            padding: '6px 10px',
                            borderRadius: '6px'
                        }}>
                            <span style={{ color: 'white', fontSize: '12px', fontWeight: 'bold' }}>
                                You {isScreenSharing && '(Screen)'}
                            </span>
                        </div>

                        {isAudioOn && (
                            <div style={{
                                position: 'absolute',
                                bottom: '8px',
                                right: '8px',
                                background: '#667eea',
                                borderRadius: '50%',
                                width: '28px',
                                height: '28px',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                fontSize: '14px'
                            }}>
                                üé§
                            </div>
                        )}
                    </div>
                )}

                {/* Remote Videos */}
                {nearbyPlayers
                    .filter(p => remoteStreams.has(p.userId) && p.isVideoOn && fullscreenVideo !== p.userId)
                    .map(player => {
                        const stream = remoteStreams.get(player.userId);
                        // const isFullscreen = fullscreenVideo === player.userId; // This is for the main fullscreen view, not the sidebar thumbnail

                        return (
                            <div
                                key={player.userId}
                                style={{
                                    position: 'relative',
                                    width: '100%',
                                    aspectRatio: '16/9',
                                    background: 'black',
                                    borderRadius: '12px',
                                    overflow: 'hidden',
                                    border: '2px solid #48bb78',
                                    boxShadow: '0 4px 12px rgba(72, 187, 120, 0.3)',
                                    cursor: 'pointer'
                                }}
                                onClick={() => setFullscreenVideo(player.userId)}
                            >
                                <video
                                    autoPlay
                                    playsInline
                                    ref={(videoElement) => {
                                        if (videoElement && stream) {
                                            videoElement.srcObject = stream;
                                        }
                                    }}
                                    style={{
                                        width: '100%',
                                        height: '100%',
                                        objectFit: 'contain'
                                    }}
                                />

                                {/* Video Controls Overlay */}
                                <div style={{
                                    position: 'absolute',
                                    top: '8px',
                                    left: '8px',
                                    right: '8px',
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center',
                                    background: 'rgba(0,0,0,0.6)',
                                    padding: '6px 10px',
                                    borderRadius: '6px'
                                }}>
                                    <span style={{
                                        color: 'white',
                                        fontSize: '12px',
                                        fontWeight: 'bold'
                                    }}>
                                        {player.userName}
                                    </span>
                                </div>

                                {/* Audio Indicator */}
                                {player.isAudioOn && (
                                    <div style={{
                                        position: 'absolute',
                                        bottom: '8px',
                                        right: '8px',
                                        background: '#48bb78',
                                        borderRadius: '50%',
                                        width: '28px',
                                        height: '28px',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        fontSize: '14px'
                                    }}>
                                        üé§
                                    </div>
                                )}
                            </div>
                        );
                    })}
            </div>
        )
    }

    {/* Message Notification Popup */ }
    {
        notification && (
            <div style={{
                position: 'fixed',
                bottom: '20px',
                right: '20px',
                background: 'rgba(0,0,0,0.9)',
                color: 'white',
                padding: '16px 20px',
                borderRadius: '12px',
                boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
                maxWidth: '300px',
                zIndex: 10000
            }}>
                <div style={{ fontWeight: 'bold', marginBottom: '8px', color: '#667eea' }}>
                    üí¨ New message from {notification.userName}
                </div>
                <div style={{ fontSize: '14px', wordWrap: 'break-word' }}>
                    {notification.message.length > 100 ? notification.message.substring(0, 100) + '...' : notification.message}
                </div>
            </div>
        )
    }
    </div >
    );
}
